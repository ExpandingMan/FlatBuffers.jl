# FlatBuffers

[![Build Status](https://travis-ci.org/dmbates/FlatBuffers.jl.svg?branch=master)](https://travis-ci.org/dmbates/FlatBuffers.jl)

A package to support Julia code generated by Google's [flatbuffers](https://google.github.io/flatbuffers/) compiler `flatc`.

Usually this support code would be in a directory of https://github.com/google/flatbuffers/ but, at present a Julia package has to be in it's own repository, so it is here.

Although the code to make flatc generate Julia source has not yet been written, it is fairly straightforward to produce the code that would be generated by hand from a _flatbuffers schema_.

This package defines an abstract type `Table`.  All concrete `FlatBuffers.Table` types have the same structure with two fields, a `FlatBuffers.TableIO`, which is just an `IO` object
and some positional information, and `FlatBuffers.Membrs` object that defines the member
names, types and defaults.  It also contains an offset into the vtable.
These usually start at `4` for the first member and increment by `2`.

The example IDL file  [`monster.fbs`](https://github.com/google/flatbuffers/blob/master/samples/monster.fbs)
```cxx
// Example IDL file for our monster's schema.

namespace MyGame.Sample;

enum Color:byte { Red = 0, Green, Blue = 2 }

union Equipment { Weapon } // Optionally add more tables.

struct Vec3 {
  x:float;
  y:float;
  z:float;
}

table Monster {
  pos:Vec3;
  mana:short = 150;
  hp:short = 100;
  name:string;
  friendly:bool = false (deprecated);
  inventory:[ubyte];
  color:Color = Blue;
  weapons:[Weapon];
  equipped:Equipment;
}

table Weapon {
  name:string;
  damage:short;
}

root_type Monster;
```

would be converted to the Julia code as

```jl
using FlatBuffers

@enum(Color, Red = 0, Green, Blue = 2)

typealias Equipment Union{Weapon}

immutable Vec3
    x::Float32
    y::Float32
    z::Float32
end

for nm in [:Weapon, :Monster]
    @eval begin
        type $nm <: FlatBuffers.Table
            io::FlatBuffers.TableIO
            memb::FlatBuffers.Membrs
        end

        $nm(io::IO, pos) = $nm(FlatBuffers.TableIO(io, pos), $(symbol(string(nm,"_members"))))
    end
end

const Weapon_members = FlatBuffers.Membrs(
    :name => (4, UTF8String, ""),
    :damage => (6, Int16, 0)
  )

const Monster_members = FlatBuffers.Membrs(
     :pos => (4, Vec3, Vec3(0, 0, 0)),
     :mana => (6, Int16. 150),
     :hp => (8, Int16, 100),
     :name => (10, UTF8String, ""),
     :friendly => (12, Bool, false),
     :inventory => (14, Vector{UInt8}, UInt8[]),
     :color => (16, UInt8, Blue),
     :weapons => (18, Vector{Weapon}, Weapon[])
     :equipped => (20, Equipment, nothing)
  )
```

At present the use of `Union` requires some care (as in, it doesn't work - you can see a way
of fudging it in the [`Feather`](https://github.com/JuliaStats/Feather.jl) repository -
and `Enum` types in the table should be typed as the appropriate size of unsigned integer
(e.g. `byte` => `UInt8`) and converted after extraction.
