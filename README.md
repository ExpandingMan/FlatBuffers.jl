# FlatBuffers

[![Build Status](https://travis-ci.org/dmbates/FlatBuffers.jl.svg?branch=master)](https://travis-ci.org/dmbates/FlatBuffers.jl)

A package to support Julia code generated by Google's [flatbuffers](https://google.github.io/flatbuffers/) compiler `flatc`.

Usually this support code would be in a directory of https://github.com/google/flatbuffers/ but, at present a Julia package has to be in it's own repository, so it is here.

Although the code to make flatc generate Julia source has not yet been written, it is fairly straightforward to produce the code that would be generated by hand from a _flatbuffers schema_.

This package defines an abstract type `Table`.  All concrete `FlatBuffers.Table` types have the same members and constructor form
```jl
using FlatBuffers

type Weapon <: FlatBuffers.Table
    io::IO
    pos::Integer
    vtablsz::Int16
    vtbloff::Int32
end

function Weapon(io::IO, pos::Integer)
    vtbloff = read(seek(io, pos), Int32)
    Weapon(io, pos, vtbloff, read(seek(io, pos - vtbloff), Int16))
end
```

In addition there is a dictionary called `members` whose values are generated from the schema for the tables.

The keys of the dictionary are the names of the members.  The tuple consists of the `vtable offset`, the `DataType` and a default value for the member.  You need to run `flatc` on the schema file to get vtable offsets.  As a stopgap I generate JavaScript and pull them out of that code.

The example schema file  [`monster.fbs`](https://github.com/google/flatbuffers/blob/master/samples/monster.fbs) contains
```cxx
// Example IDL file for our monster's schema.

namespace MyGame.Sample;

enum Color:byte { Red = 0, Green, Blue = 2 }

union Equipment { Weapon } // Optionally add more tables.

struct Vec3 {
  x:float;
  y:float;
  z:float;
}

table Monster {
  pos:Vec3;
  mana:short = 150;
  hp:short = 100;
  name:string;
  friendly:bool = false (deprecated);
  inventory:[ubyte];
  color:Color = Blue;
  weapons:[Weapon];
  equipped:Equipment;
}

table Weapon {
  name:string;
  damage:short;
}

root_type Monster;
```

If you compile it to JavaScript you will find that the vtable offsets for `Weapon` are `4` and `6`.  The `Monster` type and its entry in the `members` dictionary will be
```jl
members = Dict{DataType, Dict{Symbol, Tuple(Int16, DataType, Any)}}()

members[Weapon] =
 Dict{Symbol, Tuple(Int16, DataType, Any)}(:name => (Int16(4), UTF8string, utf8("")),
        :damage => (Int16(6), Int16, zero(Int16)))
```

After that it is downhill.

Note: The code doesn't work quite this way at present.  This commit has older code where the members dictionary was in the type instance.
