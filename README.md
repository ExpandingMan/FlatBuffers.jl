# FlatBuffers

[![Build Status](https://travis-ci.org/dmbates/FlatBuffers.jl.svg?branch=master)](https://travis-ci.org/dmbates/FlatBuffers.jl)

A package to support Julia code generated by Google's [flatbuffers](https://google.github.io/flatbuffers/) compiler `flatc`,
when that capability becomes available.
At present this package can be used by converting an IDL file, say `monster.fbs`, to
`monster.jl` by hand.  It is not horribly difficult; compare these two files in the
`test` directory.

Usually this support code would be in a directory of https://github.com/google/flatbuffers/ but, at present, a Julia package has to be in it's own repository, so it is here.

This package defines an abstract type `Table`.  All concrete `FlatBuffers.Table` types have the same structure with two fields, a `FlatBuffers.TableIO` object,
which is just an `IO` object plus some positional information, and a `FlatBuffers.Membrs` dictionary that relates a member name to its _vtable offset_, its type and a default value.
As far as I can tell, the vtable offsets always start at `4` and are incremented by `2`
for each member.

The example IDL file, `test/monster.fbs`
```cxx
// Example IDL file for our monster's schema.

namespace MyGame.Sample;

enum Color:byte { Red = 0, Green, Blue = 2 }

union Equipment { Weapon } // Optionally add more tables.

struct Vec3 {
  x:float;
  y:float;
  z:float;
}

table Monster {
  pos:Vec3;
  mana:short = 150;
  hp:short = 100;
  name:string;
  friendly:bool = false (deprecated);
  inventory:[ubyte];
  color:Color = Blue;
  weapons:[Weapon];
  equipped:Equipment;
}

table Weapon {
  name:string;
  damage:short;
}

root_type Monster;
```

is converted to the Julia code

```jl

using FlatBuffers

@enum(Color, Red = 0, Green, Blue = 2)

immutable Vec3
    x::Float32
    y::Float32
    z::Float32
end
Vec3() = Vec3(0, 0, 0)

for nm in [:Weapon, :Monster]
    @eval begin
        type $nm <: FlatBuffers.Table
            io::FlatBuffers.TableIO
            memb::FlatBuffers.Membrs
        end

        $nm(io::IO, pos) = $nm(FlatBuffers.TableIO(io, pos),$(symbol(string(nm,"_members"))))
        $nm() = $nm(IOBuffer(zeros(UInt8,4)), 0)
    end
end

typealias Equipment Union{Weapon}

const Weapon_members = FlatBuffers.Membrs(
    :name => (4, UTF8String, ""),
    :damage => (6, Int16, 0)
  )

const Monster_members = FlatBuffers.Membrs(
     :pos => (4, Vec3, Vec3()),
     :mana => (6, Int16, 150),
     :hp => (8, Int16, 100),
     :name => (10, UTF8String, ""),
     :friendly => (12, Bool, false),
     :inventory => (14, Vector{UInt8}, UInt8[]),
     :color => (16, UInt8, Blue),
     :weapons => (18, Vector{Weapon}, Weapon[]),
     :equipped => (20, Equipment, nothing)
  )
```

The `for` loop may look intimidating but it is boilerplate.
It loops over the table names, as `Symbol`s, and creates Julia types and constructors.
The only things that change are the vector of table names and the dictionary defining
its members.

If a table type `A` has a member whose type is table type `B`, then `:B` must occur before `:A` in this vector.  For example, the definition of `Monster` requires that `Weapon` be
defined first.

The conversion of the table declaration in the IDL file to the `FlatBuffers.Membrs`
object is straightforward.

Extraction from a table is by member name, as a `Symbol`.  See the examples in `test/runtests.jl`.  

At present the use of `Union` requires some care (as in, it doesn't work but you can see a way of fudging it in the [`Feather`](https://github.com/JuliaStats/Feather.jl) repository)
and `Enum` types in the table should be typed as the appropriate size of unsigned integer
(e.g. `byte` => `UInt8`) and converted after extraction.  Again, see the example of
extracting the `:color` of a monster in `test/runtest.jl`.
