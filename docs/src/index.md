# FlatBuffers.jl Documentation

#### Usage
FlatBuffers.jl provides native Julia support for reading and writing binary structures following the google flatbuffer schema (see [here](https://google.github.io/flatbuffers/flatbuffers_internals.html) for a more in-depth review of the binary format).

The typical language support for flatbuffers involves utilizing the `flatc` compiler to translate a flatbuffer schema file (.fbs) into a langugage-specific set of types/classes and methods. See [here](https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html) for the official guide on writing schemas.

This Julia package provides the serialization primitives used by code that has been generated by `flatc`. Since it was originally built without `flatc` support, it can also be used as a minimal set of macros to provide flatbuffer-compatible serialization of existing Julia types. This has led to the Julia code generated by `flatc` appearing somewhat more readable than for other languages.

For example, for this schema:
```
namespace example;

table SimpleType {
  x: int = 1;
}

root_type SimpleType;
```

the code generated by `flatc` looks like this:
```julia
module Example

using FlatBuffers
@with_kw mutable struct SimpleType
    x::Int32 = 1
end

end
```

#### Serialization
`FlatBuffers` provides the following functions for reading and writing flatbuffers.

```
serialize(stream::IO, value::T) 
deserialize(stream::IO, ::Type{T})
```

Here is how to read and write the above example using `FlatBuffers`.
```julia
using FlatBuffers, Example # the schema module we defined above

val = Example.SimpleType(2) # create an instance of our type

flatbuffer = FlatBuffers.build!(val) # start and build a flatbuffer for our SimpleType
val2 = FlatBuffers.read(flatbuffer) # now we can deserialize the value from our flatbuffer, `val2` == `val`
flatbytes = FlatBuffers.bytes(flatbuffer) # get the serialized bytes of the flatbuffer
val3 = Flatbuffers.read(Example.SimpleType, flatbytes) # now we can deserialize directly from flatbytes
```

This package provides the following types and methods:
* `FlatBuffers.Table{T}`: type for deserializing a Julia type `T` from a flatbuffer
* `FlatBuffers.Builder{T}`: type for serializing a Julia type `T` to a flatbuffer
* `FlatBuffers.read`: performs the actual deserializing on a `FlatBuffer.Table`
* `FlatBuffers.build!`: performs the actual serializing on a `FlatBuffer.Builder`

#### Methods for Generated Types
For a generated type `T`:
* if `T` has default values, constructors will be defined as per the `@with_kw` macro in [Parameters.jl](https://github.com/mauro3/Parameters.jl)
* `FlatBuffers.file_extension(T)` returns the `file_extension` specified in the schema (if any)
* `FlatBuffers.file_identifier(T)` returns the `file_identifier` specified in the schema (if any)
* `FlatBuffers.offsets(T)`: an array containing the positions of the slots in the vtable for type `T`, accounting for gaps caused by deprecated fields

Also note that no `root_type` definition is necessary in Julia; basically any type defined with `type` (i.e. not abstract or immutable) can be a valid root table type.

#### Circular References
It's a bit unfortunate that the flatbuffers example uses mutually referential types, something which Julia doesn't have support for yet.
However, there is a [workaround](https://github.com/JuliaLang/julia/issues/269#issuecomment-68421745) - by modifying the
code generated by `flatc` slightly to add a type parameter, we can refer to a type that hasn't yet been defined.
```
FlatBuffers.@with_kw mutable struct Monster{T}
    # ...
    test::T = nothing
    # ...
end
```
In general though, try to avoid schemas which introduce these kinds of circular references.
For the full `Monster` example see the test suite [here](https://github.com/dmbates/FlatBuffers.jl/tree/master/test).

#### Internal Utilities
These functions are used by the code generated by `flatc`. Documentation is also included for many
internal methods and may be queried using `?` at the REPL.
* `@ALIGN T size_in_bytes`: convenience macro for forcing a flatbuffer alignment on the Julia type `T` to `size_in_bytes`
* `@with_kw mutable struct T fields...`: convenience macro for defining default field values for Julia type `T`
* `@UNION T Union{T1,T2,...}`: convenience macro for defining a flatbuffer union type `T`
* `@STRUCT struct T fields... end`: convenience macro for defining flatbuffer struct types, ensuring any necessary padding gets added to the type definition
